+++
title = "c++存储持续性、链接性"
date = 2017-01-10
[taxonomies]
categories = ["c++修道"]
tags = ["c++", "static"]
+++

# 存储持续性
C++有四种不同的存储持续性，其间区别就是数据保留在内存中的时间：

>* 自动存储持续性：在函数定义中申明的变量（包括函数参数）的存储持续性为自动。它们在函数开始执行所属的代码块时被创建，离开所有的代码块时被释放。位于栈空间，由编译器自动管理。
>* 静态存储持续性：在函数定义外定义的变量和使用关键字`static`定义的变量的存储持续性为静态。在程序整个运行过程中都存在。
>* 动态存储持续性：由`new`运算符分配的内存将一直存在，直到使用`delete`运算符将其释放，这种内存的存储持续性为动态。位于堆空间，由程序员自己管理。
>* 线程存储chix持续性：由`thread_local`关键字申明的变量为线程存储持续性，其申明周期与所属线程一样长。

<!-- more -->

# 变量链接性
链接性描述了符号如何在不同的模块单元间共享，链接性为外部的符号可在文件间共享，链接性为内部的符号只能在其所有的一个文件中的不同函数中共享。自动存储持续性变量没有链接性，因为它们不能共享。

C++为静态存储持续性变量提供了三种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件访问）和无链接性（如自动变量，只能在当前代码块访问）。

创建链接性为外部的静态存储持续性变量，只需在代码块外部申明；－全局变量。
创建链接性为内部的静态存储持续性变量，只需在代码块外部申明且加上关键字`static`即可。－全局静态变量。
创建没有链接性的静态存储持续性变量，只需在代码块内部申明且加上关键字`static`即可。－局部静态变量。

另外，对于未显示初始化的静态存储持续性变量，其所有位都将置０。

# 例子
如果现由如下三个文件：
```
// a.hpp

#pragma once

int test_num=123;
void print();
```

```
//a.cpp
#include "a.hpp"
#include <iostream>
void print()
{
    std::cout << " TTT:: " << test_num << std::endl;
    test_num *= 10;
    std::cout << " TTT:: " << test_num << std::endl;
}
```

```
// main.cpp
#include "a.hpp"
#include <iostream>
int main()
{
    print();
    std::cout << " main::  "<< test_num << std::endl;
    return 0;
}
```

主要看a.hpp文件中的`test_num;`它在a.cpp和main.cpp中都使用了。现在它的申明方式如下：

```
int test_num=123;
```
那么此时，变量`test_num`的链接性为外部的，那么就违反了c++的单定义规则。此时，代码编译不过，报`test_num`重复定义错误。那么若改为如下：

```
static int test_num=123;
```

则此时变量`test_num`的链接性为内部的。此时代码输出：

```
123;
1230;
123;
```

从结果可以看到，编译出来的a.o和main.o两个文件中则是两个不同的`test_num`了。**也就是说，内部链接性还意味着每个文件都有自己的一组符号，而不是共享一组符号。且每个文件中的定义都是其私有的（因为内部链接性）。**

另外需注意：*C++中`const`限定符对默认的存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但`const`全局变量的链接性为内部的。*这样做的原因是如果有一组常量就可简单的放在头文件中了，否则，根据单定义规则，只能有一个文件可以包含前面的申明，其余文件必须使用`extern`关键字来提供引用申明。


# 函数链接性
和变量一样，函数也有链接性。C++中不允许在函数中定义另外一个函数，因此所有函数的存储持续性皆为静态的且默认为外部链接性。可使用关键字`static`将函数链接性设为内部的，使之只能在一个文件中使用。*必须同时在函数申明和定义中使用该关键字。*
同变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名函数，该文件仍将使用静态函数。
单定义规则同样适用于非内联函数，所有对于链接性为外部的函数只能有一个函数定义。内联函数不受此约束。
