+++
title = "c++原始指针"
date = 2018-01-10

[taxonomies]
categories = ["c++修道"]
tags = ["c++", "指针"]
+++

## 内存中的变量
为理解指针，一定需要理解C/C++中“变量”的存储实质。考虑以下程序：

```
int main() {
    char ch='h';
    int i=10;
    double d=3.14;

    printf("ch:%c &ch:%x sizeof(ch):%d \n", ch, &ch, sizeof(ch));
    printf("i: %d &i: %x sizeof(i): %d \n", i,  &i,  sizeof(i) );
    printf("d: %d &d: %x sizeof(d): %d \n", d,  &d,  sizeof(d) );

    return 0;
}
```

<!-- more -->

程序依次声明了一个字符类型变量，一个整形变量，一个双精度浮点型变量并赋给相应的值。那三个变量在内存中是如何表示的，不同的类型在内存中表示什么呢？
我们打印出上面的结果，可能如下：

```
ch:h &ch:0xbcf4179b sizeof(ch): 1
i: 10 &i:0xbcf4179c sizeof(i) : 4
d: 3.14 &d:0xbcf417a0 sizeof(d): 8
```
从结果可以看到字符型变量在内存中的大小是1个字节，内存起始地址是`0xbcf4179b`，整形变量在内存中的大小是4个字节，所以它的地址范围就是`0xbcf4179b+1=0xbcf4179c`到`0xbcf4179b+4=0xbcf4179f`，双精度浮点型变量在内存的大小的是8个字节，所以它的地址范围就是`0xbcf4179c+4=0xbcf417a0`到`0xbcf417a0+8=0xbcf417a7`。**所以，不同的类型在内存就表示了需要分配的不同的大小来容纳相应的变量。**简单表示如下：

![](/images/pointer1.png)


## 指针是什么
先来声明一个指向整形变量的指针。如下：

```
int* pi = &i;
```
我们知道，如上的语句声明了`pi`是一个指针，并且把变量`i`的地址赋给了它，但是它和上面声明的ch，i，d等变量有什么本质上的不同么？没有，它也只是一个变量而已。也是需要在内存中分配一块一定大小的内存空间来存储数据。如下图所示：

![](/images/pointer2.png)

增加如下打印语句：

```
printf("pi: %x &pi: %x *pi: %d sizeof(pi): %d\n", pi, &pi, *pi, sizeof(pi));
```
那么其打印结果应该如下：

```
pi: 0xbcf4179c &pi: 0xbcf417a7 *pi: 10 sizeof(pi): 4
```

从上可以看出，**指针变量和普通变量最主要的区别就是指针变量保存的是内存中的地址，而普通变量保存的是相应类型的值。**


## 指针和数组名
我们都知道，**数组名代表了数组的首地址。**所以，对于下面的代码都是相同的，并没有任何区别：
```
int main() {
    int arr[]={1,2,3,4,5,6,7};
    for(int i=0; i<7; ++i)
        std::cout << " " << arr[i];
    std::cout << std::endl;

    for(int i=0; i<7; ++i)
        std::cout <<" " << *(arr+i);
    std::cout << std::endl;

    int* parr = arr;
    for(int i=0; i<7; ++i)
        std::cout <<" " << parr[i];
    std::cout << std::endl;

    for(int i=0; i<7; ++i)
        std::cout <<" " << *(parr+i);
    std::cout << std::endl;

    return 0;
}
```
但是，对于下面的代码就不一样了：

```
int* parr = arr;
for(int i=0; i<7; ++i) {
    std::cout <<" " << *parr;
    ++parr;
}
```
对于上面的遍历方式，若是直接使用数组名来做则无法通过编译。原因在于**数组名是一个常量指针，其值不能被修改。**


## const 修饰指针

### const与普通变量
我们知道，如果需要一个值不能被改变的普通变量，可以使用`const`将其修饰为常量。竟然其值不能被改变，所以我们不能写出如下的代码：

```
const int i;
i = 120;
```

上面的程序会报两个错误：

```
prog.cc:8:15: error: uninitialized const 'i' [-fpermissive]
     const int i;
               ^
prog.cc:9:9: error: assignment of read-only variable 'i'
     i = 12;
```
一个对const常量未初始化，一个是对常量重新赋值。所以，我们可以知道两个有关常量的结论：**一是常量必须在声明时进行初始化，二是常量的值不能被修改。**

其实，对于`const`修饰符的位置有两种写法：

```
const type i1 = 120;
type const i2 = 210;
```

上面的两种写法是完全相同，也就是说：**类型标志符type与常量修饰符const哪个放前哪个放后都是一样的。**所以对于下面的两个指针，你应该知道他们的语义都是一样的：

```
int i1 = 23;
int i2 = 45;
const int * pi1 = &i1;
int const * pi2 = &i1;
```

### const与指针变量

const即可修饰变量，也可修饰指针，同样可以同时修饰两者。也就是下面三行代码：

```
const int * pi1;
int * const pi2;
const int * const pi3;
```

有个技巧，**对于指针变量的声明语句，我们可以简单的从右往左读来分析上面的语义。**

先来看第一行代码：

```
const int * pi1;
```
如果我们从右往左读的话是这样的：

```
pi1              ->    pi1是一个变量
* pi1            ->    pi1是一个指针变量
int * pi1        ->    pi1是一个指向int型变量的指针变量
const int * pi1  ->    pi1是一个指向const int 型变量的指针变量
```

所以，我们确定pi1是一个指向常量的指针变量。这句话是说指针本身是变量，是可以被改变的，但指针指向的值是不可以被改变的，**确切的说是不能通过指针来改变的。**例如有以下代码：

```
int main() {
    int i1 = 123;
    int i2 = 234;

    const int * pi1 = &i1;
    pi1 = &i2;  // pi1可以在改变它内存中的值。

    i2 = 23445;  // i2是变量，也可以改变它内存中的值。
    std::cout <<"i: " << *pi1 << std::endl;

    return 0;
}
```

但是如果把上面`i2=23445`改为`*pi1=23445;`则肯定编译不过。可以看到，`pi1`的值是可以改变的，即它可以重新指向另一个地址，但是不能通过`*pi1`来修改`i2`的值，即使`i2`本身是个变量。

我们还可以这样来看，首先，`const`修饰的是整个`*pi1`，所以`*pi1`是常量，不能更改，比如`*pi1=23445;`无法通过编译；其次，`pi1`前面并没有`const`修饰，所以`pi1`是指针变量，能被赋值重新指向另一个地址，比如通过`pi1=&i2;`可以改变`pi1`指向另一个地址。


同样对于第二行代码：

```
int * const pi2;
```

通过从右往左读分析出`pi2`是一个指向变量的常量指针。也就是说指针本身是常量不可更改，但指向的值是变量，是可以通过指针来更改的。

```
int main() {
    int i1 = 123;
    int i2 = 234;

    int* const pi2 = &i1;
    // pi2 = &i2;  这里无法改变指针指向的地址。

    *pi2 = 450;
    std::cout << " i: " << *pi2 << std::endl;

    return 0;
}
```

现在的情况和上面的情况完全相反了，对比上面的分析，我们知道是因为：
1. `pi2`因为`const`的修饰成了常量，无法修改`pi2`的值。
2. 整个`*pi2`前面没有`const`修饰所以为变量，可以修改`*pi2`的值。

所以，最后总结一下就是：

> 1. 如果`const`修饰符在`*`的前面，则指针指向的值是常量无法修改。
> 2. 如果`const`修饰符在`*`的后面，则指针本身是常量无法修改。
> 3. 如果`const`修饰符在`*`的前后面都存在，则两个都是常量无法修改。

上面总结的第三点则针对了第三行代码的情况，故此不做额外分析。


### const指针指向的变量情况

从前面的讨论可以看，可以把一个int型变量的地址赋值给一个指向const int 型变量的指针变量（常量），也即如下：

```
int i1 = 123;
const int * pi1 = &i1;
```

这样的代码是合法的，但是我们是否可以把一个const型变量的地址赋值给一个指向int型变量的指针变量（常量）呢？也就是下面的代码是否合法：

```
const int i2 = 234;
int *pi2 = &i2;
```

显然上面的代码是无法通过编译的。原因在于把一个常量的地址赋给一个指向变量的指针会导致矛盾。比如，上面的代码中，`i2`是一个常量保证无法更改，但是若把`i2`的赋值赋给`pi2`的话，则`pi2`又保证可以通过`*pi2`修改它所指向的值，如此产生了矛盾。

而对于第一种情况则没有这种情况。


## 指向指针的指针
在前面我们知道，指针变量和其他普通变量一样，也是在某个内存地址中的，所以指针本身也是存在一个地址的。故而我们也可能让某个指针来指向这个指针的内存地址。如下：

```
int i = 123;
int * pi = &i;
int ** ppi = &pi;
```

声明语句`int ** ppi = &pi`声明了一个指针变量`ppi`，这个`ppi`用来存储一个`int*`类型的指针变量的地址。

如果i的地址为`0x88b9bf20`，pi的地址为`0x88b9bf2c`，那么：

ppi的值则为pi的地址：0x88b9bf2c
*ppi的值则为pi的地址所保存的地址：0x88b9bf20
**ppi的值则为pi的地址所保存的地址所对应的值：123

它们在内存中布局可能如下：

![](/images/pointer3.png)

假如我们需要通过函数参数来返回一个地址的话，那指向指针的指针就是必须的了，比如我们需要在一个字符串中找到第一个符合的字符的位置的时候，可能的代码如下：

```
void find(char arr[], char ch, char* pa) {
    for(int i=0; *(arr+i); ++i) {
        if ( *(arr+i) == ch ) {
            pa = arr + i;
            break;
        }
        else
            pa = nullptr;
    }
}

int main()
{
    char arr[]={"hello,c++ pointer"};
    char ch = 'e';
    char * p = nullptr;

    find(arr, ch, p);

    if ( p == nullptr )
        std::cout <<"not found" << std::endl;
    else
        std::cout << "found"<<std::endl;
    return 0;
}
```

上面的代码肯定是输出的：not found。但实际上字符串的第二个字符既是我们要找的字符，但为什么结果却是not found呢，原因还是值传递的问题，我们传进去的指针`p`复制给了形参变量`pa`，所以对形参变量的修改并不会改变`p`的值。所以这里我们需要把指针变量`p`的地址传递进去。所以对find函数修改入下：

```
void find(char arr[], char ch, char** pa) {
    for(int i=0; *(arr+i); ++i) {
        if ( *(arr+i) == ch ) {
            *pa = arr + i;
            break;
        }
        else
            *pa = nullptr;
    }
}
```
则函数调用如下：

```
find(arr, ch, &p);  // 传递指针的地址进去。
```

需要注意的是：**地址传递其实就是地址值的传递，和值传递没什么不同。**


## 函数名和指针的关系

我们知道，函数名其实就是函数的地址。那这个函数地址是否也可以像变量那样用一个相应的指针来存储呢？是的，可以。

### 函数指针变量的声明
就像某一个数据变量的内存地址可以存储在其相应的指针变量中一样，函数的首地址也可以存储在某个函数指针变量里。这样，我们就可以通过这个函数指针变量来调用相应的函数了。

和申明指向某种数据类型的指针一样，申明函数指针时，也必须指定函数指针指向的函数类型，这就意味着申明应指定函数的返回类型和函数的形参列表。如有如下函数：

```
double* fun(int a, int b);
```

则申明指向上述函数的函数指针如下：

```
double* (*pfunc)(int a, int b);
```

仔细比较可知，两个申明的方式一样只有`fun`和`(*pfun)`的区别。我们这么看，因为`fun`是函数,则`(*pfun)`也是函数，若`(*pfun)`是函数，那么`pfun`就是函数指针了。


### 函数指针变量的调用
把函数指针指向要调用的函数地址之后，即可像正常函数调用那样调用，也可像函数指针那样，因为**函数名本身是一个函数指针常量。**

```
pfun = fun;                 // pfun指向fun函数
pfun = &fun;                // pfun同样指向fun函数
double ans2 = (*pfun)(a,b); // 使用函数指针调用fun函数
double ans3 = pfunc(a,b);   // 也可以调用
double ans4 = (*func)(a,b); // 也可以调用
double ans1 = fun(a,b);     // 前面的调用都等同于此调用
```

### 函数指针的其他事项
`typedef`的作用就是创建一个类型的别名，`typedef`也可以简化相应的函数指针，如：

```
typedef double* (*pfun)(int a, int b);
pfun fun1 = f1;
pfun fun2 = f2;
```

函数指针同样可以作为函数的参数传递，使得调用方可已根据传入的函数做不同的事情。